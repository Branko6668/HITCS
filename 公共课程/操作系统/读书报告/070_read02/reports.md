# 2. 保护模式内存管理

保护模式内存管理是一种在现代操作系统中实现内存保护和虚拟化的技术。它允许多个进程同时运行，而不会相互干扰或破坏系统的稳定性。它也提供了一种抽象的内存模型，使得程序员不需要关心物理内存的分配和回收。

## 2.1. 内存管理概览

内存管理是操作系统的一个重要功能，它负责管理计算机的内存资源，为程序提供高效、安全、灵活的内存使用环境。内存管理涉及到多种地址的转换和映射，这些地址包括：

<img src="./images/img1.png" style="zoom:60%;" />

- **逻辑地址（ Logical Address）**：也称为有效地址或段内偏移地址，是由程序产生的地址，表示程序中的某个数据或指令在其所属段中的位置。逻辑地址由段选择符和段内偏移量组成，段选择符用于指定段的编号，段内偏移量用于指定段内的相对位置。逻辑地址不能直接访问物理内存，需要经过分段机制的处理，才能得到线性地址或物理地址。

- **线性地址 （Linear Address）**：也称为虚拟地址或平坦地址，是逻辑地址经过分段机制的处理后得到的地址，表示程序中的某个数据或指令在处理器可寻址的内存空间中的位置。线性地址由段基址和段内偏移量相加得到，段基址是段的起始地址，段内偏移量是逻辑地址的一部分。线性地址也不能直接访问物理内存，需要经过分页机制的处理，才能得到物理地址。

  <img src="/images/img2.png" style="zoom:60%;" />

- **物理地址（ Physical Address）**：也称为实地址或绝对地址，是线性地址经过分页机制的处理后得到的地址，表示程序中的某个数据或指令在物理内存中的实际位置。物理地址由页框号和页内偏移量组成，页框号是物理内存中的页的编号，页内偏移量是线性地址的一部分。物理地址是最终访问物理内存的地址，由内存控制器根据物理地址从内存中读取或写入数据。

**分段管理**是一种内存管理方式，它是按照程序的逻辑结构，将程序划分为多个段，每个段有自己的属性和长度，段与段之间可以不连续。分段管理的目的是为了更好地满足用户的需求，方便编程，实现信息的保护和共享。

分段管理的主要内容包括：

- **逻辑地址**：分段管理的逻辑地址由段号和段内地址组成，段号用于指定段的编号，段内地址用于指定段内的相对位置。逻辑地址的位数决定了每个进程最多可以分几个段，以及每个段的最大长度。
- **段表**：段表是每个进程的段映射表，用于记录每个段在内存中的起始位置（基址）和段的长度。段表的每个表项称为段表项，段表项的长度是相同的。段表的起始地址和长度通常存放在段表寄存器中。
- **地址转换**：地址转换是将逻辑地址转换为物理地址的过程，需要通过查询段表来完成。地址转换的步骤如下：
    - 根据逻辑地址得到段号和段内地址。
    - 判断段号是否越界，即是否超过段表的长度。
    - 查询段表，找到对应的段表项，检查段内地址是否超过段长。
    - 计算物理地址，物理地址等于段基址加上段内地址。
    - 访问目标内存单元。

分段管理和分页管理的对比如下：

|                   分段管理                   |                    分页管理                    |
| :------------------------------------------: | :--------------------------------------------: |
|           按照程序的逻辑结构划分段           |              按照固定的大小划分页              |
|           每个段有自己的属性和长度           |          每个页有自己的属性，长度相同          |
|         逻辑地址由段号和段内地址组成         |         逻辑地址由页号和页内偏移量组成         |
|          段表记录每个段的基址和段长          |             页表记录每个页的页框号             |
|             地址转换需要查询段表             |              地址转换需要查询页表              |
| 段的长度不固定，需要检查段内地址是否超过段长 | 页的长度固定，不需要检查页内偏移量是否超过页长 |
|    段与段之间可以不连续，可能产生外部碎片    |     页与页之间可以不连续，不会产生外部碎片     |
|      对用户可见，用户编程时需要给出段名      |     对用户不可见，用户编程时不需要给出页号     |
|          更容易实现信息的保护和共享          |          不太容易实现信息的保护和共享          |



## 2.2. 分段机制

**分段机制**是一种内存管理机制，它是按照程序的逻辑结构，将程序划分为多个段，每个段有自己的属性和长度，段与段之间可以不连续。分段机制的目的是为了实现内存的保护、共享和扩充。

分段机制的基本原理是，每个段都有一个段描述符，用于存放段的基址、段长、段属性等信息。段描述符存放在全局描述符表（GDT）或局部描述符表（LDT）中，这些表的起始地址和长度存放在相应的寄存器中。每个段都有一个段选择符，用于指定段的编号和所属的表。段选择符存放在段寄存器中，如CS、DS、SS等。CPU在访问内存时，需要根据段寄存器中的段选择符，从相应的表中找到段描述符，然后根据段描述符中的基址和段长，以及指令或数据中的偏移量，计算出线性地址。线性地址是程序中的某个数据或指令在处理器可寻址的内存空间中的位置。线性地址也不能直接访问物理内存，需要经过分页机制的处理，才能得到物理地址。

分段机制有多种模型，根据段的数量和大小，可以分为以下几种：

- **Basic Flat Model**：基本平坦模型，也称为单段模型，是指只使用一个段，该段占据整个线性地址空间，不进行分段。这种模型简化了地址转换，提高了访存效率，但是不能实现内存的保护和共享，也不能扩充内存空间。这种模型适合于实模式下的操作，或者用于嵌入式系统。

  <img src="/images/img3.png" style="zoom:67%;" />

- **Protected Flat Model**：保护平坦模型，也称为扩展平坦模型，是指使用一个段，该段占据整个线性地址空间，但是使用保护位来实现内存的保护。这种模型保留了基本平坦模型的优点，同时增加了内存的安全性，但是仍然不能实现内存的共享和扩充。这种模型适合于保护模式下的操作，或者用于实时操作系统。

  ​           <img src="/images/img4.png" style="zoom: 67%;" />

- **Multi-Segment Model**：多段模型，是指使用多个段，每个段占据一部分线性地址空间，可以进行分段。这种模型充分利用了分段机制的功能，可以实现内存的保护、共享和扩充，但是增加了地址转换的复杂度，降低了访存效率。这种模型适合于保护模式下的操作，或者用于多任务操作系统。<img src="/images/img5.png" style="zoom:67%;" />

## 2.3. 逻辑地址和线性地址的转换

**逻辑地址和线性地址的转换**是分段机制的核心，它是将程序产生的逻辑地址（也称为有效地址或段内偏移地址）转换为处理器可寻址的线性地址（也称为虚拟地址或平坦地址）的过程。逻辑地址和线性地址的转换涉及到以下几个概念：

- **段选择子 Segment Selectors**：段选择子是一个16位的值，用于指定段的编号和所属的表（GDT或LDT）。段选择子由三个部分组成：索引（Index）、表指示位（TI）和请求特权级（RPL）。索引是一个13位的值，用于指定段在GDT或LDT中的位置。表指示位是一个1位的值，用于指定段所属的表，0表示GDT，1表示LDT。请求特权级是一个2位的值，用于指定访问段的最低特权级，0表示最高特权级，3表示最低特权级。
- **段寄存器 Segment Registers**：段寄存器是用于存放段选择子的寄存器，有六个段寄存器，分别是CS（代码段寄存器）、DS（数据段寄存器）、SS（堆栈段寄存器）、ES（附加数据段寄存器）、FS（附加数据段寄存器）和GS（附加数据段寄存器）。段寄存器的值可以通过MOV指令或者LES、LSS、LDS、LFS、LGS等指令来修改，但是CS寄存器不能直接修改，需要通过跳转或者调用指令来修改。<img src="/images/img6.png" style="zoom:67%;" />
- **段描述符 Segment Descriptors**：段描述符是一个64位的值，用于存放段的基址、段长、段属性等信息。段描述符由两个32位的字组成，分为低字和高字。低字由四个部分组成：段限长低位（Limit 0-15）、段基址低位（Base 0-15）、段基址中位（Base 16-23）和段类型（Type）。高字由五个部分组成：段类型（Type）、描述符特权级（DPL）、段存在位（P）、段限长高位（Limit 16-19）、可用位（AVL）、保留位（0）、默认操作数大小（D/B）、粒度位（G）和段基址高位（Base 24-31）。

**逻辑地址和线性地址的转换的步骤如下**：

- 根据逻辑地址得到段选择子和段内偏移量。
- 根据段选择子的表指示位，确定是从GDT还是LDT中查找段描述符。
- 根据段选择子的索引，从相应的表中找到对应的段描述符。
- 根据段描述符的段存在位，判断段是否在内存中，如果不在，触发缺页异常。
- 根据段描述符的描述符特权级和段选择子的请求特权级，判断是否有访问权限，如果没有，触发一般保护异常。
- 根据段描述符的段类型，判断是否符合访问类型，如果不符合，触发一般保护异常。
- 根据段描述符的段限长和段内偏移量，判断是否越界，如果越界，触发一般保护异常或者栈异常。
- 根据段描述符的段基址和段内偏移量，计算出线性地址，线性地址等于段基址加上段内偏移量。

## 2.4. 描述符的分类

描述符是用于存放段或者门的信息的数据结构，每个描述符的长度是8个字节，由两个32位的字组成。描述符的通用格式如下：

|   31-24    |               23-16                |    15-8    |    7-0     |
| :--------: | :--------------------------------: | :--------: | :--------: |
| Base 24-31 | G D/B AVL Limit 16-19 P DPL S Type | Base 16-23 | Limit 0-15 |
| Base 0-15  |                Type                | Base 8-15  |  Base 0-7  |

描述符的主要字段有：

- **Base**：用于存放段的基地址，即段在线性地址空间中的起始位置，占32位，可以是0~4GB范围内的任意地址。
- **Limit**：用于存放段的限长，即段的长度，占20位，可以是1B~1MB或者4KB~4GB，具体取决于颗粒度位G的值。
- **Type**：用于存放段或者门的类型，占4位，具体含义取决于描述符类型位S的值。
- **S**：用于存放描述符类型，占1位，S=0表示系统描述符，S=1表示存储段描述符（即代码段或者数据段）。
- **DPL**：用于存放描述符特权级，占2位，表示访问该描述符所需的最低特权级，范围是0~3，0表示最高，3表示最低。
- **P**：用于存放段存在位，占1位，表示该段是否在内存中，P=0表示不在，P=1表示在。
- **AVL**：用于存放可用位，占1位，供操作系统使用，处理器不使用。
- **D/B**：用于存放默认操作数大小/默认栈指针大小和上界限，占1位，对于代码段，该位表示默认的操作数和地址的大小，D/B=0表示16位，D/B=1表示32位；对于栈段，该位表示隐含堆栈操作时的栈指针大小，D/B=0表示使用SP寄存器，D/B=1表示使用ESP寄存器。
- **G**：用于存放颗粒度位，占1位，表示段限长字段Limit的单位，G=0表示单位是B，G=1表示单位是4KB。<img src="/images/img7.png" style="zoom:67%;" />

根据描述符类型位S的不同，描述符可以分为两大类：存储段描述符和系统描述符。存储段描述符用于存放代码段或者数据段的信息，系统描述符用于存放门或者其他系统段的信息。下面分别介绍这两类描述符的子类。

- **存储段描述符**：当S=1时，表示存储段描述符，此时Type字段的最高位（第2个双字的位11）用于区分代码段描述符和数据段描述符，Type=0表示数据段描述符，Type=1表示代码段描述符。存储段描述符的格式如下：

|   31-24    |               23-16                |    15-8    |    7-0     |
| :--------: | :--------------------------------: | :--------: | :--------: |
| Base 24-31 | G D/B AVL Limit 16-19 P DPL 1 Type | Base 16-23 | Limit 0-15 |
| Base 0-15  |              A W E 0               | Base 8-15  |  Base 0-7  |

- **数据段描述符 Data segment Descriptor**：数据段描述符是GDT和LDT中的一个数据结构项，用于向处理器提供有关一个段的位置、大小以及访问控制的状态信息。

-  **代码段描述符 Code segment Descriptor**：代码段描述符与数据段描述符类似，也是GDT和LDT中的一个数据结构项，但它指向的是代码段。

<img src="/images/img8.png" style="zoom:67%;" />

-  **系统描述符**：当S=0时，表示系统描述符，此时Type字段的四位（第2个双字的位8~11）用于区分不同类型的系统描述符，包括局部描述符表描述符、任务状态段描述符、调用门描述符、中断门描述符、陷阱门描述符和任务门描述符。系统描述符的格式如下：

|   31-24    |              23-16               |    15-8    |    7-0     |
| :--------: | :------------------------------: | :--------: | :--------: |
| Base 24-31 | G 0 AVL Limit 16-19 P DPL 0 Type | Base 16-23 | Limit 0-15 |
| Base 0-15  |               Type               | Base 8-15  |  Base 0-7  |

- **局部描述符表描述符 Local descriptor-table (LDT) segment descriptor**：局部描述符表（LDT）是保护模式下存储器寻址的一种数据表，它包含了与某个任务相关联的段描述符。

- **任务状态段描述符 Task-state segment (TSS) descriptor**：任务状态段 (Task State Segment)是保存一个任务重要信息的特殊段。任务状态段描述符用于描述这样的系统段。

- **调用门描述符 Call-gate descriptor**：调用门描述符被 CALL和JUMP指令以代码段描述符相同的方式使用。当硬件识别出目的选择符引用了一个门描述符时，指令的操作以调用门内容决定的方式被扩展。

- **中断门描述符 Interrupt-gate descriptor**：中断门描述符用于中断处理，其类型码为110，中断门包含了一个外设中断或故障中断的处理程序所在段的选择子和段内偏移量。当控制权通过中断门进入中断处理程序时，处理器清IF标志，即关中断，以避免嵌套中断的发生。

- **陷阱门描述符 Trap-gate descriptor**：陷阱门描述符用于系统调用，其类型码为111，与中断门类似，其唯一的区别是，控制权通过陷阱门进入处理程序时维持IF标志位不变，也就是说，不关中断。

- **任务门描述符 Task-gate descriptor**：任务门描述符提供了对TSS的间接、受保护的引用。任务门的SELECTOR字段必须引用一个TSS描述符。

<img src="/images/img9.png" style="zoom:67%;" />



