# x86 系统架构概览

x86 系统架构是一种广泛使用的计算机体系结构，它支持多种操作系统和应用程序。x86 系统架构的主要特点是：

- 采用 32 位或 64 位的寻址空间，支持多达 4 GB 或 16 EB 的物理内存和虚拟内存。
- 采用分段和分页的内存管理机制，实现内存保护和虚拟化。
- 支持两种操作模式：实模式和保护模式。实模式是一种简单的操作模式，主要用于启动系统和兼容旧的软件。保护模式是一种高级的操作模式，提供了多任务、多用户、多处理器和异常处理等功能。
- 提供了丰富的指令集，包括数据传输、算术逻辑、控制转移、字符串处理、浮点运算、系统管理等指令。
- 提供了多种寄存器，用于存储数据、地址、状态和控制信息。其中，系统级寄存器是用于控制系统运行状态和配置的重要寄存器。

本报告将详细介绍 x86 系统架构的以下内容：

​		系统级体系结构概览

​		实模式和保护模式转换

- 80x86 系统指令寄存器
- 系统指令

## 1.1. 系统级体系结构概览

x86 系统级体系结构是指 x86 处理器在保护模式下的运行环境，它包括了系统级寄存器和数据结构，以及相应的访问和操作方法。

<img src="./images/img1.png" style="zoom:60%;" />

图 2.1 给出了 x86 系统级体系结构的示意图，其中包括了以下部分：

- 全局描述符表（Global Descriptor Table, GDT）：
  - 一个存储在内存中的数据结构，用于定义系统中所有可用的段（Segment），包括代码段、数据段、堆栈段、系统段等。每个段都由一个 8 字节的段描述符（Segment Descriptor）来描述，包含了段的基地址、限长、属性等信息。GDT 的基地址和限长由 GDTR 寄存器来保存。

- 局部描述符表（Local Descriptor Table, LDT）：

  - 一个存储在内存中的数据结构，用于定义某个任务（Task）所使用的私有段。每个任务都有一个自己的 LDT，其基地址和限长由 LDTR 寄存器来保存。LDT 中的段描述符与 GDT 中的相同。
- 系统段， 段描述符， 门（System Segments, Segment Descriptors, and Gates）：

  - 系统结构中定义了两种系统段结构，分别为任务状态段 (TTS) 和局部描述符表。分别有对应定义的段描述符去访问他们。而 全局描述符表并不是一个段结构，因此也没有对应的段描述符或者段选择器其访问他。

  - 系统结构中同样定义了一种特殊的描述符，叫 门 (gates) ，具体的门种类有：call gates, interrupt gates, trap gates, task gates 。他提供了一种受保护的方式去调用跨特权的系统调用或者处理。当权限较低的代码段需要访问更高权限的代码段时，可以通过调用门的方式，获取到目标代码段的段描述符，有时也需要更改权限为目标代码段的所在权限。从而实现访问。
- 中断描述符表（Interrupt Descriptor Table, IDT）：

  - 一个存储在内存中的数据结构，用于定义系统中所有可用的中断（Interrupt）和异常（Exception）处理程序。每个中断或异常都由一个 8 字节的门（Gate）来描述，包含了处理程序的段选择子（Segment Selector）、偏移量、属性等信息。IDT 的基地址和限长由 IDTR 寄存器来保存。
- 任务状态段（Task-State Segment, TSS）：

  - 一个存储在内存中的数据结构，用于保存某个任务的运行状态信息，包括寄存器值、堆栈指针、优先级等。每个任务都有一个自己的 TSS，其基地址由 TR 寄存器来保存。TSS 中还包含了一个任务门（Task Gate），用于切换到该任务。
- 中断和异常处理（Interrupt and Exception Handling）：

  - 当发生中断或异常时，处理器会根据 IDT 中的相应门来转移到对应的处理程序，同时保存当前任务的状态信息到 TSS 中，并加载新任务的状态信息。中断和异常的处理过程涉及到多种系统段和门，包括中断门（Interrupt Gate）、陷阱门（Trap Gate）、调用门（Call Gate）等。
- 内存管理（Memory Management）：

  - x86 系统使用分段和分页的内存管理机制，实现了内存的保护和虚拟化。分段是指将内存划分为多个逻辑单元，每个单元由一个段描述符来定义。分页是指将内存划分为多个固定大小的物理单元，称为页（Page）。每个页都有一个 32 位的页目录项（Page Directory Entry, PDE）或页表项（Page Table Entry, PTE）来描述，包含了页的物理地址、属性等信息。页目录（Page Directory）和页表（Page Table）是存储在内存中的数据结构，用于实现虚拟地址到物理地址的映射。页目录的基地址由 CR3 寄存器来保存。
- 系统寄存器（System Registers）：

  为了帮助处理器的初始化和系统的控制，系统结构中设置了一些系统标志寄存器

  - EFLAGS 寄存器 控制着任务和模式选择，中断处理，指令跟踪和访问权限。

  - 控制寄存器（CR0、CR2、CR3和CR4） 包含用于各种系统级操作的标志和控制字段

  - 调试寄存器 允许设置断点，供程序调试和系统软件中使用

  - GDTR,LDTR,IDTR 包含各个表的线性地址

  - 任务寄存器 TR 包含当前任务在 TTS 中描述符的线性地址

## 1.2. 实模式和保护模式转换

实地址模式-此操作模式提供Intel 8086处理器的编程环境，并带有一些扩展（例如切换到受保护或系统管理模式的能力）。

保护模式-这是处理器的本机操作模式。它提供了一组丰富的架构特性、灵活性、高性能和与现有软件库的向后兼容性。

x86 处理器在上电或复位后，会进入实模式，此时处理器只能访问 1 MB 的物理内存空间，且没有内存保护和多任务功能。为了使用保护模式的功能，需要进行以下步骤：

- 设置 GDT，并将其基地址和限长加载到 GDTR 寄存器中。GDT 中至少要包含一个代码段描述符和一个数据段描述符，用于定义保护模式下的代码段和数据段。
- 设置 IDT，并将其基地址和限长加载到 IDTR 寄存器中。IDT 中至少要包含一个中断门或陷阱门，用于定义保护模式下的中断或异常处理程序。
- 设置 CR0 寄存器的 PE 位为 1，表示启用保护模式。
- 执行一条跳转指令（如 JMP），用于清除指令流水线，并将代码段选择子和代码段偏移量加载到 CS 和 EIP 寄存器中，从而开始在保护模式下执行代码。

从保护模式返回实模式的步骤与上述相反，主要包括：

- 设置 CR0 寄存器的 PE 位为 0，表示禁用保护模式。
- 执行一条跳转指令（如 JMP），用于清除指令流水线，并将实模式下的代码段选择子和代码段偏移量加载到 CS 和 EIP 寄存器中，从而开始在实模式下执行代码。

在实模式和保护模式之间切换时，还需要注意以下几点：

- 在切换到保护模式前，应该禁用所有外部中断（如通过 CLI 指令），以避免在切换过程中发生不可预知的中断。
- 在切换到保护模式后，应该重新设置所有段寄存器（如 DS, ES, FS, GS, SS），以加载相应的段选择子，并将段寄存器的可见部分清零。
- 在切换到实模式前，应该保存所有需要保留的数据到实模式可访问的内存区域（如低于 1 MB 的地址空间），以避免数据丢失。
- 在切换到实模式后，应该重新设置所有段寄存器（如 DS, ES, FS, GS, SS），以加载相应的段基地址，并将段寄存器的可见部分设置为合适的值。

## 1.3. 80x86 系统指令寄存器

80x86 系统指令寄存器是用于存储和控制系统指令的执行结果和状态的寄存器，它们包括以下几类：

- 标志寄存器 EFLAGS：一个 32 位的寄存器，用于保存算术逻辑指令、控制转移指令、系统管理指令等的执行结果和状态。EFLAGS 寄存器包含了以下位：
  - CF（Carry Flag）位：用于表示无符号运算的进位或借位。
  - PF（Parity Flag）位：用于表示运算结果的最低字节中 1 的个数的奇偶性。
  - AF（Auxiliary Carry Flag）位：用于表示无符号运算的半字节进位或借位。
  - ZF（Zero Flag）位：用于表示运算结果是否为零。
  - SF（Sign Flag）位：用于表示有符号运算结果的符号位。
  - TF（Trap Flag）位：用于控制单步调试模式。
  - IF（Interrupt Enable Flag）位：用于控制是否允许外部中断。
  - DF（Direction Flag）位：用于控制字符串处理指令的方向。
  - OF（Overflow Flag）位：用于表示有符号运算的溢出。
  - IOPL（I/O Privilege Level）位：用于表示当前任务的 I/O 特权级别，取值为 0 到 3。
  - NT（Nested Task）位：用于表示当前任务是否是嵌套任务。
  - RF（Resume Flag）位：用于控制是否忽略调试异常。
  - VM（Virtual-8086 Mode）位：用于控制是否进入虚拟 8086 模式。
  - AC（Alignment Check）位：用于控制是否启用对齐检查。
  - VIF（Virtual Interrupt Flag）位：用于在虚拟 8086 模式下模拟 IF 位。
  - VIP（Virtual Interrupt Pending）位：用于在虚拟 8086 模式下表示是否有挂起的中断。
  - ID（ID Flag）位：用于表示处理器是否支持 CPUID 指令。
  
- 内存管理寄存器，包括 GDTR，LDTR，IDTR，TR：
  - GDTR 寄存器：一个 48 位的寄存器，用于保存 GDT 的基地址和限长。GDTR 寄存器可以通过 LGDT 和 SGDT 指令来加载和保存。
  - LDTR 寄存器：一个 16 位的寄存器，用于保存 LDT 的段选择子。LDTR 寄存器可以通过 LLDT 和 SLDT 指令来加载和保存。
  - IDTR 寄存器：一个 48 位的寄存器，用于保存 IDT 的基地址和限长。IDTR 寄存器可以通过 LIDT 和 SIDT 指令来加载和保存。
  - TR 寄存器：一个 16 位的寄存器，用于保存 TSS 的段选择子。TR 寄存器可以通过 LTR 和 STR 指令来加载和保存。
  
- 控制寄存器，包括 CR0 至 CR3,图 2.7 给出了控制寄存器的示意图：

  <img src="./images/img2.png" style="zoom:60%;" />

  - CR0 寄存器：一个 32 位的寄存器，用于控制系统的运行状态和配置。CR0 寄存器包含了 PE, PG, CD, NW, AM, WP, NE 等位，它们已经在前面介绍过了。
  - CR1 寄存器：一个保留的寄存器，不能被访问或修改。
  - CR2 寄存器：一个 32 位的寄存器，用于保存最近发生页错误的线性地址。CR2 寄存器只能被读取，不能被修改。
  - CR3 寄存器：一个 32 位的寄存器，用于保存页目录的基地址。CR3 寄存器可以通过 MOV 指令来加载和保存。

## 1.4.系统指令

系统指令是一类用于访问和操作系统级寄存器和数据结构的指令，加载和保存 GDT，LDT，IDT，TSS 的指令，包括 LGDT，SGDT，LIDT，SIDT，LLDT，SLDT，LTR，STR。这些指令的操作数可以是内存地址或寄存器，用于指定要加载或保存的数据的位置。这些指令的格式如下：

- LGDT m16&32：
  - 将内存中的 48 位数据加载到 GDTR 寄存器中，其中低 16 位为 GDT 的限长，高 32 位为 GDT 的基地址。
- SGDT m16&32：
  - 将 GDTR 寄存器中的 48 位数据保存到内存中，其中低 16 位为 GDT 的限长，高 32 位为 GDT 的基地址。
- LIDT m16&32：
  - 将内存中的 48 位数据加载到 IDTR 寄存器中，其中低 16 位为 IDT 的限长，高 32 位为 IDT 的基地址。
- SIDT m16&32：
  - 将 IDTR 寄存器中的 48 位数据保存到内存中，其中低 16 位为 IDT 的限长，高 32 位为 IDT 的基地址。
- LLDT r/m16：
  - 将寄存器或内存中的 16 位数据加载到 LDTR 寄存器中，作为 LDT 的段选择子。
- SLDT r/m16：
  - 将 LDTR 寄存器中的 16 位数据保存到寄存器或内存中，作为 LDT 的段选择子。
- LTR r/m16：
  - 将寄存器或内存中的 16 位数据加载到 TR 寄存器中，作为 TSS 的段选择子。
- STR r/m16：
  - 将 TR 寄存器中的 16 位数据保存到寄存器或内存中，作为 TSS 的段选择子。

